ðŸ—ƒ dek - the decorator-decorator ðŸ—ƒ
======================================================

``dek`` decorates your decorators to diminish defects and drudgery.

Writing a decorator with parameters needs three levels of function and offers
several opportunities for error, dull drudgery ``dek`` deletes.

EXAMPLE:

Write a decorator ``print_before`` that prints a function's arguments with a
label when it executes

.. code-block:: python

    # Without dek all is confusion

    import functools

    def print_before(label='label'):
        def deferred(func):
            @functools.wraps(func)
            def wrapped(*args, **kwargs):
                print(label, args, kwargs)
                return func(*args, **kwargs)

            return wrapped

        if callable(label):
            return deferred(label)

        return deferred


    # Things go clearer with dek
    from dek import dek

    @dek
    def print_before(func, label='debug'):
        print(label, func.args, func.keywords)
        return func()


    # Or use defer mode for more control
    @dek(defer=True)
    def print_before(func, label='debug'):
        def wrapped(foo, bar):
            print(label, foo, bar)
            return func(foo, bar)

        return wrapped

NOTES:

Decorators can be called in many ways:

* ``@print_before``
* ``@print_before()``
* ``@print_before('debug')``
* ``@print_before(label='debug')``
* ``@print_before('debug', verbose=True)``

`This article <https://medium.com/better-programming/how-to-write-python-decorators-that-take-parameters-b5a07d7fe393>`_ talks more about
decorators that take parameters.

For advanced problems, the PyPi library
`decorator <https://github.com/micheles/decorator/blob/master/docs/documentation.md>`_ does not do what ``dek`` does, but does pretty anything
else you could conceive of in a decorator library.

API
---

``dek.dek(decorator, defer=False, methods=False)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(`dek.py, 80-172 <https://github.com/rec/dek/blob/master/dek.py#L80-L172>`_)

Implement a decorator that works with or without parameters and
understands classes.

dek has two modes, simple and defer.  Simple mode, the default,
is less work but offers less control.

* In simple mode, ``decorator`` is a single function that does all the work

* In defer mode, ``decorator`` is a function that returns a function that
  that does the work.

.. code-block:: python

   @dek
   def print_before(func, label='debug'):  # simple mode
       print(label, func.args, func.keywords)
       return func()

   @dek(defer=True)
   def print_before(func, label='label'):  # defer mode
       def wrapper(foo, bar):
           if verbose:
               print(label, foo, bar)
           return func(foo, bar)

       return wrapper

The ``methods`` parameter says how classes are treated:

* If ``methods`` is ``False`` then classes are decorated like any callable;
  otherwise, classes are not decorated, but their methods might be.

* If ``methods`` is ``True`` then only methods whose names start with ``_``
  are decorated

* If ``methods`` is a string then only methods whose names start
  with that string are decorated (which means that if ``methods`` is
  the empty string, that all methods are decorated)

* If ``methods`` is a callable then only methods that return true when
  passed to this callable are decorated

(automatically generated by `doks <https://github.com/rec/doks/>`_ on 2020-07-07T17:22:03.526927)
